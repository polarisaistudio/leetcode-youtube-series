# 第1天：两数之和 (LeetCode #1) - 中文脚本

## 免责声明
**教育内容声明**：此视频仅供教育目的。所提供的解决方案和解释旨在帮助您理解算法概念并为技术面试做准备。请确保您理解概念而不是死记硬背解决方案。

## 开场 (30秒)

"欢迎回到我们的LeetCode精通系列！我是你们的主持人，今天我们要解决经典的两数之和问题 - LeetCode第1题。这是一道简单难度的题目，但不要小看它 - 这是谷歌、亚马逊、Facebook和微软等公司最常问的面试题之一。让我们开始吧！"

## 题目描述 (2分钟)

"让我来读一下题目：

**给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，且不能使用相同的元素。**

让我们用一个例子来可视化：

```
输入数组：    [2,  7,  11, 15]
下标：        0   1   2   3
目标值：9

可视化过程：
┌─────┬─────┬─────┬─────┐
│  2  │  7  │ 11  │ 15  │  ← 数组值
├─────┼─────┼─────┼─────┤
│  0  │  1  │  2  │  3  │  ← 下标
└─────┴─────┴─────┴─────┘

寻找：? + ? = 9
发现：2 + 7 = 9 (下标 0, 1)

输出：[0, 1]
```

需要注意的重要约束：
- 每个输入只有一个解
- 不能使用同一个元素两次
- 数组可能包含重复值
- 我们需要返回下标，而不是值本身

**面试中我会问的问题：**
```
问：数组可以为空吗？
答：不可以，至少保证有2个元素

问：数字是排序的吗？
答：不假设排序

问：可以有负数吗？
答：可以，整数可以是负数

问：如果没有解怎么办？
答：题目保证恰好有一个解
```"

## 解决方案 (4分钟)

### 方法1：暴力解法

"最直观的方法是检查每一对数字：

```
算法可视化：
数组：[2, 7, 11, 15]，目标值：9

嵌套循环过程：
i=0 → j=1: 检查 2+7=9  ✓ 找到了！
i=0 → j=2: 检查 2+11=13 ✗
i=0 → j=3: 检查 2+15=17 ✗
i=1 → j=2: 检查 7+11=18 ✗
i=1 → j=3: 检查 7+15=22 ✗
i=2 → j=3: 检查 11+15=26 ✗

总比较次数：n(n-1)/2 = O(n²)
```

**伪代码：**
```
对于 i 从 0 到 n-1：
    对于 j 从 i+1 到 n：
        如果 nums[i] + nums[j] == target：
            返回 [i, j]
```

**复杂度：**
- 时间：O(n²) - 嵌套循环
- 空间：O(1) - 常量额外空间"

### 方法2：哈希表（最优解）

"关键洞察：对于每个数字，我们确切知道我们在寻找什么！

```
哈希表方法可视化：
数组：[2, 7, 11, 15]，目标值：9

逐步过程：
┌─────┬─────────────┬─────────────┬─────────────┐
│步骤 │  当前数字   │ 需要(9-x)   │  哈希表     │
├─────┼─────────────┼─────────────┼─────────────┤
│  1  │     2       │      7      │ {2: 0}      │
│  2  │     7       │      2      │ 找到2了！   │
└─────┴─────────────┴─────────────┴─────────────┘

结果：[0, 1] (2和7的下标)
```

**算法流程：**
1. 对于每个数字 `x`，计算 `补数 = 目标值 - x`
2. 检查 `补数` 是否存在于哈希表中
3. 如果存在 → 返回两个下标
4. 如果不存在 → 将 `x` 及其下标存入哈希表

**可视化哈希表操作：**
```
nums = [2, 7, 11, 15], target = 9

i=0: num=2, 补数=7
     哈希表 = {} 
     7未找到 → 存储：哈希表 = {2: 0}

i=1: num=7, 补数=2  
     哈希表 = {2: 0}
     2找到了！→ 返回 [哈希表[2], i] = [0, 1]
```"

## 实时编程 (7分钟)

"让我实现两个解决方案：

**解决方案1：暴力解法**
```python
def twoSum_bruteforce(nums, target):
    \"\"\"
    暴力解法：检查所有配对
    时间：O(n²)，空间：O(1)
    \"\"\"
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []  # 根据题目约束永远不会到达
```

**解决方案2：哈希表（最优）**
```python
def twoSum_optimal(nums, target):
    \"\"\"
    哈希表：单次遍历解决方案
    时间：O(n)，空间：O(n)
    \"\"\"
    seen = {}  # 值 -> 下标映射
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in seen:
            return [seen[complement], i]
        
        seen[num] = i
    
    return []  # 根据题目约束永远不会到达
```

**让我们跟踪示例：**

```
示例1：nums=[2,7,11,15], target=9
───────────────────────────────────────
i=0, num=2, 补数=7
seen = {}, 7未找到
seen = {2: 0}

i=1, num=7, 补数=2  
seen = {2: 0}, 2找到了！
返回 [0, 1] ✓

示例2：nums=[3,2,4], target=6
──────────────────────────────────
i=0, num=3, 补数=3
seen = {}, 3未找到
seen = {3: 0}

i=1, num=2, 补数=4
seen = {3: 0}, 4未找到  
seen = {3: 0, 2: 1}

i=2, num=4, 补数=2
seen = {3: 0, 2: 1}, 2找到了！
返回 [1, 2] ✓
```"

## 复杂度分析 (2分钟)

"让我们比较我们的解决方案：

```
复杂度比较图表：
┌─────────────┬─────────┬─────────┬─────────────────┐
│    方法     │  时间   │  空间   │      描述       │
├─────────────┼─────────┼─────────┼─────────────────┤
│  暴力解法   │  O(n²)  │  O(1)   │  检查所有配对   │
│  哈希表     │  O(n)   │  O(n)   │  单次遍历       │
└─────────────┴─────────┴─────────┴─────────────────┘

时间增长可视化：
数组大小 │ 暴力解法  │ 哈希表
─────────────────────────────────────
   100   │  10,000   │   100
 1,000   │1,000,000  │ 1,000  
10,000   │100,000,000│10,000

空间-时间权衡：
- 暴力解法：不需要额外空间，但O(n²)时间
- 哈希表：O(n)额外空间，但O(n)时间
```

**何时使用每种方法：**
- **暴力解法**：内存极其有限时
- **哈希表**：需要最优时间复杂度时（99%的情况）"

## 常见陷阱 (1分钟)

"注意这些错误：

```python
# ❌ 错误：使用同一元素两次
def twoSum_wrong(nums, target):
    for i in range(len(nums)):
        for j in range(i, len(nums)):  # 应该是 i+1
            if nums[i] + nums[j] == target:
                return [i, j]

# ❌ 错误：返回值而不是下标  
def twoSum_wrong2(nums, target):
    # ... 逻辑 ...
    return [nums[i], nums[j]]  # 应该返回 [i, j]

# ❌ 错误：没有正确处理重复值
nums = [3, 3], target = 6
# 应该返回 [0, 1]，而不是因为值相同而跳过

# ✅ 正确：处理边界情况
def twoSum_robust(nums, target):
    if len(nums) < 2:
        return []
    
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
```"

## 相关问题 (30秒)

"掌握两数之和后，挑战这些：

```
问题进阶路径：
两数之和 (简单)          → 三数之和 (中等)        → 四数之和 (中等-困难)
     ↓                       ↓                       ↓
两数之和 II (简单)      → 最接近的三数之和 (中等) → 四数之和 II (中等)
     ↓                        
两数之和 III (中等)    
     ↓
两数之和 IV - BST (简单)

模式识别：
- 无序数据使用哈希表
- 有序数据使用双指针  
- K数之和问题的多种方法
```"

## 面试技巧 (1分钟)

"**面试策略：**

1. **先澄清问题** (30秒)
   ```
   \"我可以假设数组至少有2个元素吗？\"
   \"我应该返回下标还是值？\"
   \"如果有多个解怎么办？\"
   ```

2. **从简单开始** (1分钟)
   ```
   \"让我从暴力解法开始...\"
   [实现 O(n²) 解决方案]
   ```

3. **优化** (2-3分钟)
   ```
   \"我们能做得更好吗？如果我们使用额外空间呢？\"
   [实现 O(n) 解决方案]
   ```

4. **测试与调试** (1分钟)
   ```python
   # 用提供的示例测试
   assert twoSum([2,7,11,15], 9) == [0,1]
   # 测试边界情况
   assert twoSum([3,3], 6) == [0,1]
   ```

**预期后续问题：**
```
问：如果数组是排序的呢？
答：使用双指针 - O(n)时间，O(1)空间

问：如果我们需要所有配对呢？
答：找到第一个后继续搜索

问：大数组的内存约束？
答：考虑外部排序，分布式处理
```"

## 结尾 (30秒)

"这就是两数之和！关键要点：

✅ 哈希表为补数查找提供O(1)查找  
✅ 空间-时间权衡在优化中很常见  
✅ 面试中总是澄清需求  
✅ 从简单开始，然后优化  

明天我们将探讨'买卖股票的最佳时机' - 另一个具有类似优化模式的数组问题。

如果这个视频对你有帮助请点赞，订阅获取每日LeetCode内容，在评论中提出你的问题！编程愉快！🚀"

---

**视频时长**：约15-18分钟
**关键文件**：查看 `images/` 文件夹获取可视化图表
**下期视频**：第2天 - 买卖股票的最佳时机 (#121)