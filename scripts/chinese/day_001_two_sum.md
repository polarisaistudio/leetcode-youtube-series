# 第1天：两数之和 (LeetCode #1)

## 开场 (30秒)

"欢迎回到我们的LeetCode精通系列！我是你们的主持人，今天我们要解决经典的两数之和问题 - LeetCode第1题。这是一道简单难度的题目，但不要小看它 - 这是谷歌、亚马逊、Facebook和微软等公司最常问的面试题之一。让我们开始吧！"

## 题目描述 (2分钟)

"让我来读一下题目：

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

让我们通过一个例子来更好地理解这个问题。

[参考: illustration_1_two_sum_example.png]

如果我们有 nums = [2, 7, 11, 15]，target = 9，我们需要找到两个数字加起来等于9。我们可以看到 2 + 7 = 9，它们的下标是0和1，所以我们返回 [0, 1]。

需要注意的重要约束：
- 每个输入只有一个解
- 不能使用同一个元素两次
- 数组可能包含重复值
- 我们需要返回下标，而不是值本身

在面试中，我会问：
- 数组可以为空吗？（不能，至少有2个元素）
- 数字是排序的吗？（不是）
- 可以有负数吗？（可以）
- 如果没有解应该返回什么？（题目保证有解）"

## 解决方案 (4分钟)

### 方法1：暴力解法

"最直观的方法是检查每一对数字。

[参考: illustration_2_brute_force.png]

对于每个元素，我们检查它与其他每个元素的和是否等于目标值。这个方法可行，但效率不高。

```
对于 i 从 0 到 n-1：
    对于 j 从 i+1 到 n：
        如果 nums[i] + nums[j] == target：
            返回 [i, j]
```

时间复杂度：O(n²) - 我们有嵌套循环
空间复杂度：O(1) - 只使用常量额外空间"

### 方法2：哈希表（最优解）

"关键洞察：对于每个数字，我们确切地知道我们在寻找什么数字 - 它是 `target - 当前数字`。与其搜索它，我们可以将看过的数字存储在哈希表中！

[参考: illustration_3_hash_table.png]

当我们遍历数组时：
1. 计算补数：`complement = target - 当前数字`
2. 检查补数是否存在于哈希表中
3. 如果存在，我们找到了配对！返回下标
4. 如果不存在，将当前数字和它的下标添加到哈希表

这个单次遍历的解决方案效率更高！"

## 实时编码 (7分钟)

"让我编写两个解决方案，从暴力解法开始展示进步过程：

```python
def twoSum_bruteforce(nums, target):
    n = len(nums)
    # 检查每一对数字
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []  # 根据题目约束，这行不应该被执行到
```

现在，让我们实现优化的哈希表解决方案：

```python
def twoSum(nums, target):
    # 字典存储 值 -> 下标 的映射
    seen = {}
    
    for i, num in enumerate(nums):
        # 计算我们需要的数字
        complement = target - num
        
        # 检查我们之前是否见过这个补数
        if complement in seen:
            return [seen[complement], i]
        
        # 存储当前数字和它的下标
        seen[num] = i
    
    return []  # 这行不应该被执行到
```

让我们跟踪我们的例子：
- nums = [2, 7, 11, 15], target = 9
- i=0, num=2, complement=7, seen={}, 7不在seen中, 添加 2->0
- i=1, num=7, complement=2, seen={2:0}, 2在seen中！返回 [0, 1]

完美！让我们用另一个例子测试：
- nums = [3, 2, 4], target = 6
- i=0, num=3, complement=3, seen={}, 添加 3->0
- i=1, num=2, complement=4, seen={3:0}, 添加 2->1
- i=2, num=4, complement=2, seen={3:0, 2:1}, 2在seen中！返回 [1, 2]"

## 复杂度分析 (2分钟)

"让我们分析复杂度：

[参考: illustration_4_complexity_comparison.png]

**暴力解法：**
- 时间：O(n²) - 对于每个元素，我们检查n-1个其他元素
- 空间：O(1) - 不需要额外空间

**哈希表：**
- 时间：O(n) - 单次遍历数组
- 空间：O(n) - 最坏情况下，我们在哈希表中存储所有n个元素

这里的权衡是经典的：我们牺牲空间换取时间。在大多数情况下，O(n)的时间复杂度值得额外的O(n)空间。"

## 常见陷阱 (1分钟)

"注意这些常见错误：

1. **使用同一个元素两次**：确保你的第二个循环从i+1开始，而不是i
2. **返回值而不是下标**：题目要求返回下标！
3. **没有正确处理重复值**：[3, 3] 目标值6应该返回 [0, 1]
4. **负数的边界情况**：[-1, -2, -3, -4, -5] 目标值-8
5. **忘记在哈希表中存储下标**：我们需要值和下标"

## 相关问题 (30秒)

"掌握两数之和后，试试这些相关问题：
- 三数之和 (LeetCode #15) - 扩展到三个数字
- 四数之和 (LeetCode #18) - 扩展到四个数字
- 两数之和 II (LeetCode #167) - 数组已排序
- 两数之和 III (LeetCode #170) - 数据结构设计
- 两数之和 IV (LeetCode #653) - 在BST中"

## 面试技巧 (1分钟)

"在面试环境中：

1. **从澄清问题开始** - 展示对细节的关注
2. **先讨论暴力解法** - 展示你能快速想出解决方案
3. **逐步优化** - 展示问题解决过程
4. **大声思考** - 面试官想了解你的思考过程
5. **测试你的代码** - 在说完成之前走一遍例子

期待的后续问题：
- 如果数组是排序的怎么办？（可以使用双指针 - O(n)时间，O(1)空间）
- 如果我们需要所有和为目标值的配对怎么办？（找到第一个后继续搜索）
- 如何处理非常大的数组？（讨论内存约束）
- 能用O(1)空间解决吗？（只有排序时可以 - 使用双指针）"

## 结尾 (30秒)

"这就是两数之和！我们介绍了两种方法，分析了复杂度，并讨论了面试策略。关键要点：哈希表对于查找配对和补数非常强大。

明天，我们将解决'买卖股票的最佳时机' - 另一个基于今天概念的数组问题。

如果你觉得这很有帮助，请点赞并订阅！有任何问题请留言，记住 - 持续练习是掌握这些问题的关键。明天见！"